/** 
@mainpage
<h2>Алгоритм</h2>
Решение разделено на 2 этапа:
	<ol>
    <li>Построение регулярного автомата</li>
    <li>Получение решения по автомату</li>
    </ol>

<b>Построение автомата</b><br>
Изначально создаем следующий автомат: есть только начальное и конечное состояния, между ними есть ребро на котором записано регулярное выражение. Затем до тех пор, пока хоть одно действие было выполнено выполняется процедура build от корня, которая "релаксирует" все ребра данной вершины, а затем рекурсивно запускаятся от всех детей данной вершины. Релаксация выполняется следующим образом: если выражение - это слово длины 1 или пустое слово, то ничего не происходит. Иначе определяется последняя операция и её операнды и ребро изменяется по следующим правилам: если операция - это '+', то ребро разделяется на 2 новых ребра, на каждом из которых записано по операнду, если операция - это '.', то создается новая вершина такая, что в неё входит ребро из данной по первому операнду и выходит ребро в старую - по второму, если же операция - это '*', то добавляется цикл в себя по тому выражению, которое нужно итерировать и ребро по пустому слову туда, куда вело изначальное ребро. Понятно, что изменяя автомат таким образом мы можем только уменьшать длину регулярных выражений на ребрах, и в итоге получим только однобуквенные переходы и переходы по пустому слову.<br>
Корректность построения для автомата из однобуквенных и единичных регудярных выражений очевидна. Для более сложных доказываем по индукции по максимальной длине регулярки: как было описано выше, при каждом изменении автомата регулярное выражение либо разбивается на 2 более мелких, либо просто уменьшается.<br>
<br>
<b>Получение решения</b><br>
Для начала научимся проверять принадлежность произвольного слова языку с помощью уже построенного автомата. Это делает матод check автомата. Этот метод поддерживает массив всех тех состояний автомата, в которые можно прийти по некоторому префиксу слова. Изначально в массив добавляется начальное состояние. На каждой итерации мы добавляем всевозможные переходы по пустому слову в активные состояния, затем из всех активных добавляем всевозможные переходы по очередной букве и снова добавляем переходы по пустому слову. Если после чтения всех букв в множестве активных состояний есть хоть одно конечное, то слово лежит в языке, иначе - не лежит.<br>
Тогда просто проверим все суффиксы слова на пренадлежность языку начиная с всего слова и заканчивая пустым словом. Если какой-то из них лежит в языке, то вернем его длину, иначе ни один из суффиксов не лежит в языке и ответ INF.
*/ 
